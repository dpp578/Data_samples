''' 
Description:      This is the endpoint API that gets triggered whenever user clicks the update button in the UI.
                  The API will connect to both RDS and FOPS database. The database' credentials for each 7 tray pack plant will be passed into the environment vairables.
                  This app.py pulls all updates from RDS (a copy of S4 HANA) and updates FOPS database of each plan in one run. There will be 7 runs in total.
                  Specifically, it gets the data from RDS and properly updates the info in FOPS based on sales_document and legacy_material_number.
Functions:        1. Create an endpoint API to be called by the client using the PUT method
                  2. Connect to RDS MySQL DB
                  3. Connect to FOPS SQL Server DB
                  4. Get the data from RDS database
                  5. Update FOPS based on given data from RDS
Author:           June Pham
Technical Owner:  Jacob Hannan
Date:             8/1/2019
Status:           Work in Progress. Finishing up testing
'''

#Import package for SQL Server, MySQL
import pyodbc, pymysql
import os, logging
#flask for API
from flask import Flask, request
#WSGI server
from gevent.pywsgi import WSGIServer
import sys


#Create Api objects
app = Flask(__name__)
counter = 0

# 1. Create an endpoint API to be called by the client using the PUT method
@app.route('/update', methods=['PUT'])
def updateDB():  
  #Connect to RDS My SQL DB
  rds_conn = connectRDS()

  #Connect to FOPS DB
  fops_conn = connectFOPS()

  #Get data from RDS to update data in FOPS
  getRDSdata(rds_conn, fops_conn)

  #Close database connections
  fops_conn.close()
  printf('Disconnected FOPS.')
  rds_conn.close()
  printf('Disconnected RDS.')

  #If succeeds, return 200
  global counter 
  counter += 1
  return 'Hello, World! ' + str(counter), 200


# 2. Connect to RDS MySQL DB
def connectRDS():
  printf('Connecting to RDS.')
  port = int(os.environ['RDS_DB_PORT'])
  rds_conn = pymysql.connect(host=os.environ['RDS_DB_HOST'],
                            user=os.environ['RDS_DB_USER'],
                            port=port,
                            password=os.environ['RDS_DB_PASS'], 
                            db=os.environ['RDS_DB_NAME'])
  
  printf('Connected to RDS {}.'.format(os.environ['RDS_DB_NAME']))
  return rds_conn


# 3. Connect to FOPS SQL Server DB
def connectFOPS():
  printf('Connecting to FOPS.')
  server = os.environ['DB_SERVER']
  username = os.environ['DB_UID']
  password = os.environ['DB_PASS']
  database = os.environ['DB_NAME']
  fops_conn = pyodbc.connect('DRIVER={ODBC Driver 17 for SQL Server};SERVER='+server+';PORT=1433;UID='+username+';PWD='+ password+';DATABASE='+ database)
  printf('Connected to FOPS {}.'.format(os.environ['DB_NAME']))
  return fops_conn


# 4. Get the data from RDS database
''' 
  Parameters: 1. rds_conn:  RDS connection
              2. fops_conn: FOPS connection
'''
def getRDSdata(rds_conn, fops_conn):
  #Create cursor for RDS
  rds_cursor = rds_conn.cursor()
  rds_cursor.execute("""SELECT  `Legacy Material Number`, `Sales Document`, `Final Cases`
                        FROM    allocation_vw
                         WHERE 	`Updated At` >= SYSDATE() - INTERVAL 7 DAY
                                AND 
                                `Last Edited By` IS NOT NULL;""") #WHERE UPDATED_AT is within 1 week
  #Get all returned rows in a results list
  results = rds_cursor.fetchall()

  #Ignore Split Orders, Assuming getRDSdata will only return maximum 1 row per sales order
  #Get the values of each row from RDS
  for row in results:
    #Get and split material number based on "-"
    material        = row[0].split('-')
    #brand = last 4 digits of material
    brand           = int(material[1])
    #product = next 6 digits before last 4 digits of material
    product         = int(material[0])
    #Get Ordered Quantity and Sales order number
    orderQuantity   = int(row[2]) 
    saleOrderNumber = int(row[1])
    
    #Call update function
    updateFOPS(fops_conn, orderQuantity, saleOrderNumber, product, brand)
  
  printf('FOPS Database is updated.')
  rds_cursor.close()


# 5. Update FOPS based on given data from RDS
''' 
  Parameters: 1. fops_conn:       FOPS connection
              2. orderQuantity:   ordered quantity from RDS
              3. saleOrderNumber: sales document from RDS
              4. product:         a part of the material number from RDS
              5. brand:           a part of the material number from RDS
'''
def updateFOPS(fops_conn, orderQuantity, saleOrderNumber, product, brand):
  fops_cursor = fops_conn.cursor()
  fops_cursor.execute("""UPDATE 
                      dbo.ORDER_FILE 
                    SET 
                      ORDERED_QUANTITY = {order_quantity} 
                    WHERE 
                      ORDER_FILE_ID = (SELECT 
                                        DISTINCT ORF.ORDER_FILE_ID
                                      FROM 
                                        ORDER_DETAIL OD
                                        INNER JOIN ORDER_FILE ORF
                                        ON 
                                          ORF.REVISION_NUMBER = OD.REVISION_NUMBER 
                                          AND 
                                          ORF.SALES_ORDER_NUMBER = OD.SALES_ORDER_NUMBER
                                      WHERE 
                                        OD.SALES_ORDER_NUMBER = {sales_order_number} 
                                        AND 
                                        SIM_PRODUCT = {product} 
                                        AND 
                                        SIM_BRAND = {brand} );"""
                                      .format(order_quantity=orderQuantity, 
                                              sales_order_number=saleOrderNumber, 
                                              product=product, 
                                              brand=brand)) 
  fops_cursor.close()
  fops_conn.commit()
  
def printf(comment): 
  return print(comment)

#If the module is called directly
if __name__ == '__main__':
  #Run a WSGI server 
  #app.run(debug=False) #-- Flask runner, can only responds to 1 request at a time
  server = WSGIServer(('', 5000), app)
  
  #Non stop
  server.serve_forever()

  #test with postman: http://localhost:5000/update
 
  
  
